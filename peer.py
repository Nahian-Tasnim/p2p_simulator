# -*- coding: utf-8 -*-
"""peer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s_jkLzI-TkGgVmtcgHOXsdcvrU6HgwAJ
"""

import socket
import threading
import queue
import random
import time
from .message import MessageType, HandshakeMessage, PieceMessage
from ..utils.logger import P2PLog
from ..utils.file_handler import FileHandler

class Peer:
    def __init__(self, peer_id, host, port, config):
        self.peer_id = peer_id
        self.host = host
        self.port = port
        self.config = config
        self.log = P2PLog(peer_id)
        self.connected_peers = {}           # peer_id -> socket
        self.event_queue = queue.Queue()
        self.pieces = set()                 # Track which pieces we have
        self.file_handler = FileHandler(config.file_name, config.piece_size)
        self._server_thread = threading.Thread(target=self.listen_for_connections)
        self._server_thread.start()
        self.interested_peers = set()       # Peers that are interested in us
        self.uploaded_pieces = 0            # Count of pieces uploaded
        self.downloaded_pieces = 0          # Count of pieces downloaded
        self.choked_peers = {}              # Track if a peer choked us last round
        self.upload_speed = {}
        self.download_speed = 0
        self.optimistic_unchoke_thread = threading.Thread(target=self.optimistic_unchoke_loop)
        self.optimistic_unchoke_thread.start()

    def listen_for_connections(self):
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.bind((self.host, self.port))
        server_socket.listen(self.config.max_connections)
        self.log.info(f"Peer {self.peer_id} listening on {self.host}:{self.port}")
        while True:
            conn, addr = server_socket.accept()
            threading.Thread(target=self.handle_connection, args=(conn, addr)).start()

    def handle_connection(self, conn, addr):
        data = conn.recv(1024)
        if data:
            self.log.info(f"Received handshake from {addr}")
            self.event_queue.put(("HANDSHAKE_RECEIVED", addr))
        while True:
            data = conn.recv(4096)
            if not data:
                break
            self.event_queue.put(("MESSAGE_RECEIVED", data))

    def connect_to_peer(self, other_peer_id, host, port):
        if other_peer_id in self.connected_peers:
            return
        a = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        a.connect((host, port))
        self.connected_peers[other_peer_id] = a
        handshake = HandshakeMessage(self.config.handshake_header, self.peer_id)
        a.sendall(str(handshake).encode('utf-8'))
        self.log.info(f"Sent handshake to peer {other_peer_id}")

    def send_message(self, peer_id, message):
        if peer_id in self.connected_peers:
            s = self.connected_peers[peer_id]
            s.sendall(str(message).encode('utf-8'))
            self.log.debug(f"Sent message to {peer_id}: {message}")
        else:
            self.log.error(f"Cannot send message to {peer_id}. Not connected.")

    def process_event(self, event):
        event_type, event_data = event
        if event_type == "HANDSHAKE_RECEIVED":
            self.log.info(f"Processing handshake event from {event_data}.")
            self.send_bitfield()
            self.request_piece()
        elif event_type == "MESSAGE_RECEIVED":
            self.log.info("Processing message event.")
            self.handle_message(event_data)
        elif event_type == "CONNECT_PEER":
            target_peer_id = event_data['target_peer_id']
            target_host = event_data['host']
            target_port = event_data['port']
            self.connect_to_peer(target_peer_id, target_host, target_port)
        else:
            self.log.error(f"Unknown event type: {event_type}")

    def send_bitfield(self):
        bitfield = [1 if i in self.pieces else 0 for i in range(self.config.file_size // self.config.piece_size)]
        self.send_message(self.peer_id, Message(MessageType.BITFIELD, payload=bitfield))

    def handle_message(self, data):
        message_type = MessageType(data[0])
        if message_type == MessageType.REQUEST:
            piece_index = data[1]
            self.send_piece(piece_index)
        elif message_type == MessageType.PIECE:
            piece_index = data[1]
            piece_data = data[2:]
            self.receive_piece(piece_index, piece_data)

    def send_piece(self, piece_index):
        if piece_index in self.pieces:
            piece_data = self.file_handler.read_piece(piece_index)
            piece_message = PieceMessage(piece_index, piece_data)
            self.send_message(self.peer_id, piece_message)
            self.uploaded_pieces += 1
            self.upload_speed[piece_index] = len(piece_data) / self.config.piece_size       # Updates upload speed
            self.log.info(f"Sent piece {piece_index} to peer {self.peer_id}")

    def receive_piece(self, piece_index, data):
        self.pieces.add(piece_index)
        self.file_handler.write_piece(piece_index, data)
        self.downloaded_pieces += 1
        self.download_speed += len(data) / self.config.piece_size          # Updates download speed
        self.log.info(f"Received piece {piece_index} from peer.")
        self.request_piece()            # Request another piece after receiving one
        self.update_upload_speed()
        self.tit_for_tat()              # Uses tit-fot-tat for choking and unchoking peers

    def request_piece(self):
        rarest_piece = self.get_rarest_piece()
        if rarest_piece is not None:
            self.send_message(self.peer_id, Message(MessageType.REQUEST, payload={'piece_index': rarest_piece}))
            self.log.info(f"Requested piece {rarest_piece} from peers.")
        else:
            self.log.info("No rare pieces available to request.")

    def get_rarest_piece(self):           # Finds the rarest piece for exchanging
        piece_counts = {}
        for peer_id in self.connected_peers:
            if peer_id in self.interested_peers:
                for piece in self.connected_peers[peer_id].pieces:
                    if piece not in piece_counts:
                        piece_counts[piece] = 0
                    piece_counts[piece] += 1
        rarest_piece = None
        min_count = float('inf')
        for piece, count in piece_counts.items():
            if count < min_count and piece not in self.pieces:
                min_count = count
                rarest_piece = piece
        return rarest_piece

    def tit_for_tat(self):         # Unchokes top 3 peers together
        sorted_peers = sorted(self.upload_speed.items(), key=lambda x: x[1], reverse=True)
        top_peers = [peer_id for peer_id, _ in sorted_peers[:3]]
        for peer_id in top_peers:
            if peer_id not in self.choked_peers or not self.choked_peers[peer_id]:
                self.send_message(peer_id, Message(MessageType.UNCHOKE))
                self.log.info(f"Unchoked peer {peer_id}.")
        for peer_id in self.connected_peers:
            if peer_id not in top_peers:
                self.send_message(peer_id, Message(MessageType.CHOKE))
                self.choked_peers[peer_id] = True
                self.log.info(f"Choked peer {peer_id}.")

    def optimistic_unchoke_loop(self):
        while True:
            time.sleep(30)
            self.optimistic_unchoke()

    def optimistic_unchoke(self):               # Unchokes 1 peer optimistically after every 30 seconds
        if self.connected_peers:
            optimistic_peer = random.choice(list(self.connected_peers.keys()))
            self.send_message(optimistic_peer, Message(MessageType.UNCHOKE))
            self.log.info(f"Optimistically unchoked peer {optimistic_peer}.")

    def is_active(self):
        return len(self.pieces) < (self.config.file_size // self.config.piece_size)

    def has_completed(self):
        total_pieces = self.config.file_size // self.config.piece_size
        return len(self.pieces) == total_pieces



class Seed(Peer):
    def __init__(self, peer_id, host, port, config):
        super().__init__(peer_id, host, port, config)
        self.pieces = set(range(config.file_size // config.piece_size))      # Seed has all pieces


class Leecher(Peer):
    def __init__(self, peer_id, host, port, config, pieces):
        super().__init__(peer_id, host, port, config)
        self.pieces = pieces