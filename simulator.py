# -*- coding: utf-8 -*-
"""simulator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YOKGAcWeevClhBeeOQ2ijFPxc2bVwRQe
"""

class Simulator:
    """
    Manages the global timeline, event queue, and coordinate the behavior of multiple peers.
    """
    def __init__(self, event_queue, peers):
        self.event_queue = event_queue
        self.peers = peers
        self.current_time = 0
        self.log = logging.getLogger("Simulator")
        self.log.setLevel(logging.INFO)
        self.start_time = None                 # Initialize the start time for the global timer

    def run(self):
        timeout = 300
        start_time = time.time()               # Start the global timer
        while not self.event_queue.is_empty() and (time.time() - start_time) < timeout:     # Ternimate yhe simulation when the event queue is empty
            event = self.event_queue.pop()
            self.current_time = event.time
            self.dispatch_event(event)
        total_time = time.time() - self.start_time

        self.check_completion()

    def dispatch_event(self, event):
        event_type = event.event_type
        data = event.data
        if 'peer_id' in data:
            peer_id = data['peer_id']
            if peer_id in self.peers:
                self.peers[peer_id].process_event((event_type, data))
        elif event_type == "CONNECT_PEER":
            target_peer_id = data['target_peer_id']
            target_host = data['host']
            target_port = data['port']
            if target_peer_id in self.peers:
                self.peers[target_peer_id].process_event((event_type, data))
        else:
            self.log.error(f"Unknown event type: {event_type}")

    def check_completion(self):
        all_completed = all(peer.has_completed() for peer in self.peers.values())
        if all_completed:
            print("Simulation terminating.")
        else:
            print("Some peers are still active.")

    def schedule_event(self, time, event_type, data):
        event = Event(time, event_type, data)
        self.event_queue.push(event)